diff -Nur -x '*.orig' -x '*~' gnome-settings-daemon-2.21.91/plugins/mouse/gsd-mouse-manager.c gnome-settings-daemon-2.21.91.new/plugins/mouse/gsd-mouse-manager.c
--- gnome-settings-daemon-2.21.91/plugins/mouse/gsd-mouse-manager.c	2008-01-14 17:49:29.000000000 +0000
+++ gnome-settings-daemon-2.21.91.new/plugins/mouse/gsd-mouse-manager.c	2008-02-14 08:16:12.000000000 +0000
@@ -57,6 +57,10 @@
 #define KEY_LOCATE_POINTER      "/desktop/gnome/peripherals/mouse/locate_pointer"
 #define KEY_DWELL_ENABLE        "/desktop/gnome/accessibility/mouse/dwell_enable"
 #define KEY_DELAY_ENABLE        "/desktop/gnome/accessibility/mouse/delay_enable"
+#define KEY_TOUCHPAD_ENABLED    "/desktop/gnome/peripherals/mouse/touchpad_enabled"
+#define KEY_TAP_TO_CLICK        "/desktop/gnome/peripherals/mouse/tap_to_click"
+#define KEY_PAD_VERT_SCROLL     "/desktop/gnome/peripherals/mouse/pad_vert_scroll"
+#define KEY_PAD_HORIZ_SCROLL    "/desktop/gnome/peripherals/mouse/pad_horiz_scroll"
 
 struct GsdMouseManagerPrivate
 {
@@ -395,6 +399,161 @@
                                0, 0, motion_threshold);
 }
 
+static int
+set_touchpad_enabled (gboolean state)
+{
+	int numdevices, i;
+	int values[2];
+        XDeviceInfo *devicelist = XListInputDevices (GDK_DISPLAY(), &numdevices);
+	XDeviceResolutionControl c;
+	
+	values[0] = 0;
+	values[1] = state ? 0 : 1; /* setting is touchpad off */
+	c.control = DEVICE_RESOLUTION;
+	c.length = sizeof(XDeviceResolutionControl);
+	c.first_valuator = 0;
+	c.num_valuators = 2;
+	c.resolutions = values;
+
+	for (i = 0; i < numdevices; i++) {
+		if (strcmp (devicelist[i].name, "Synaptics Touchpad") == 0) {
+			XDevice * device ;
+			gdk_error_trap_push();
+			device = XOpenDevice(GDK_DISPLAY(),
+					     devicelist[i].id);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error: Touchpad configured as core pointer.");
+				continue;
+			}
+			gdk_error_trap_push();
+			XChangeDeviceControl (GDK_DISPLAY(), device,
+					      DEVICE_RESOLUTION, &c);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error in setting tap to click");
+				continue;
+			}
+			XCloseDevice (GDK_DISPLAY(), device);
+		}
+	}
+	return 0;
+}
+
+static int
+set_tap_to_click (gboolean state)
+{
+	int numdevices, i;
+	int values[2];
+        XDeviceInfo *devicelist = XListInputDevices (GDK_DISPLAY(), &numdevices);
+	XDeviceResolutionControl c;
+	
+	values[0] = 1;
+	values[1] = state;
+	c.control = DEVICE_RESOLUTION;
+	c.length = sizeof(XDeviceResolutionControl);
+	c.first_valuator = 0;
+	c.num_valuators = 2;
+	c.resolutions = values;
+
+	for (i = 0; i < numdevices; i++) {
+		if (strcmp (devicelist[i].name, "Synaptics Touchpad") == 0) {
+			XDevice * device ;
+			gdk_error_trap_push();
+			device = XOpenDevice(GDK_DISPLAY(),
+					     devicelist[i].id);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error: Touchpad configured as core pointer.");
+				continue;
+			}
+			gdk_error_trap_push();
+			XChangeDeviceControl (GDK_DISPLAY(), device,
+					      DEVICE_RESOLUTION, &c);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error in setting tap to click");
+				continue;
+			}
+			XCloseDevice (GDK_DISPLAY(), device);
+		}
+	}
+	return 0;
+}
+
+static int
+set_vert_scroll (gboolean state)
+{
+	int numdevices, i;
+	int values[2];
+        XDeviceInfo *devicelist = XListInputDevices (GDK_DISPLAY(), &numdevices);
+	XDeviceResolutionControl c;
+	
+	values[0] = 2;
+	values[1] = state;
+	c.control = DEVICE_RESOLUTION;
+	c.length = sizeof(XDeviceResolutionControl);
+	c.first_valuator = 0;
+	c.num_valuators = 2;
+	c.resolutions = values;
+
+	for (i = 0; i < numdevices; i++) {
+		if (strcmp (devicelist[i].name, "Synaptics Touchpad") == 0) {
+			XDevice * device ;
+			gdk_error_trap_push();
+			device = XOpenDevice(GDK_DISPLAY(),
+					     devicelist[i].id);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error: Touchpad configured as core pointer.");
+				continue;
+			}
+			gdk_error_trap_push();
+			XChangeDeviceControl (GDK_DISPLAY(), device,
+					      DEVICE_RESOLUTION, &c);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error in setting vertical scroll");
+				continue;
+			}
+			XCloseDevice (GDK_DISPLAY(), device);
+		}
+	}
+	return 0;
+}
+
+static int
+set_horiz_scroll (gboolean state)
+{
+	int numdevices, i;
+	int values[2];
+        XDeviceInfo *devicelist = XListInputDevices (GDK_DISPLAY(), &numdevices);
+	XDeviceResolutionControl c;
+	
+	values[0] = 3;
+	values[1] = state;
+	c.control = DEVICE_RESOLUTION;
+	c.length = sizeof(XDeviceResolutionControl);
+	c.first_valuator = 0;
+	c.num_valuators = 2;
+	c.resolutions = values;
+
+	for (i = 0; i < numdevices; i++) {
+		if (strcmp (devicelist[i].name, "Synaptics Touchpad") == 0) {
+			XDevice * device ;
+			gdk_error_trap_push();
+			device = XOpenDevice(GDK_DISPLAY(),
+					     devicelist[i].id);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error: Touchpad configured as core pointer.");
+				continue;
+			}
+			gdk_error_trap_push();
+			XChangeDeviceControl (GDK_DISPLAY(), device,
+					      DEVICE_RESOLUTION, &c);
+			if (gdk_error_trap_pop()) {
+				g_warning("Error in setting horizontal scroll");
+				continue;
+			}
+			XCloseDevice (GDK_DISPLAY(), device);
+		}
+	}
+	return 0;
+}
 
 #define KEYBOARD_GROUP_SHIFT 13
 #define KEYBOARD_GROUP_MASK ((1 << 13) | (1 << 14))
@@ -597,6 +756,18 @@
                 if (entry->value->type == GCONF_VALUE_INT) {
                         set_motion_threshold (manager, gconf_value_get_int (entry->value));
                 }
+	} else if (! strcmp (entry->key, KEY_TOUCHPAD_ENABLED)) {
+		if (entry->value->type == GCONF_VALUE_BOOL)
+			set_touchpad_enabled (gconf_value_get_bool (entry->value));
+	} else if (! strcmp (entry->key, KEY_TAP_TO_CLICK)) {
+		if (entry->value->type == GCONF_VALUE_BOOL)
+			set_tap_to_click (gconf_value_get_bool (entry->value));
+	} else if (! strcmp (entry->key, KEY_PAD_VERT_SCROLL)) {
+		if (entry->value->type == GCONF_VALUE_BOOL)
+			set_vert_scroll (gconf_value_get_bool (entry->value));
+	} else if (! strcmp (entry->key, KEY_PAD_HORIZ_SCROLL)) {
+		if (entry->value->type == GCONF_VALUE_BOOL)
+                        set_horiz_scroll (gconf_value_get_bool (entry->value));
         } else if (! strcmp (entry->key, KEY_LOCATE_POINTER)) {
                 if (entry->value->type == GCONF_VALUE_BOOL) {
                         set_locate_pointer (manager, gconf_value_get_bool (entry->value));
@@ -662,6 +833,11 @@
                                 gconf_client_get_bool (client, KEY_DWELL_ENABLE, NULL),
                                 gconf_client_get_bool (client, KEY_DELAY_ENABLE, NULL));
 
+	set_touchpad_enabled (gconf_client_get_bool (client, KEY_TOUCHPAD_ENABLED, NULL));
+	set_tap_to_click (gconf_client_get_bool (client, KEY_TAP_TO_CLICK, NULL));
+	set_vert_scroll (gconf_client_get_bool (client, KEY_PAD_VERT_SCROLL, NULL));
+	set_horiz_scroll (gconf_client_get_bool (client, KEY_PAD_HORIZ_SCROLL, NULL));
+
         g_object_unref (client);
 
         return TRUE;
